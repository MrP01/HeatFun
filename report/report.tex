\documentclass[12pt, a4paper]{article}
\PassOptionsToPackage{sharp}{prettytex/boxes}
\usepackage{prettytex/base}

\setlength{\topmargin}{0.0in}
\setlength{\oddsidemargin}{0.33in}
\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.0in}
\renewcommand{\baselinestretch}{1.25}

\usepackage{prettytex/math}
\usepackage{prettytex/math-theorems}
\usepackage{prettytex/mathematicians}
\usepackage{prettytex/gfx}
\usepackage{prettytex/code}
\usepackage{prettytex/pseudo}
\usepackage{prettytex/thesis}
\usepackage{cleveref}
\usepackage{lipsum}

\setlength{\headheight}{19.53pt}
\setlength{\headsep}{1.8em}
\setlength{\belowcaptionskip}{-12pt}
\addbibresource{sources.bib}

\newcommand{\topictitle}{Solving PDEs using Spectral Methods in the Chebyshev basis \\ \large by example of the Heat Equation}
\newcommand{\candidatenumber}{12345}
\newcommand{\course}{Approximation of Functions}

\title{\topictitle}
\author{Candidate \candidatenumber}
\date{\today}

\newcommand*{\todo}{\colorbox{green}}

% Outline:
% ✅ Setting: define heat equation PDE problem (with BCs), explain series in x direction
% ✅ Introduce Chebyshev polynomials (relation of x, z and theta)
% ✅ Prove recurrence relation
% ✅ Prove orthogonality
% ✅ - Using transformation to theta
% ✅ - cite Cauchy integral for Laurent series
% ✅ Define Lipschitz
% Define Function Space in Cheb Basis
% ✅ Introduce Cheb series
% Algorithm one: interpolantThrough()
% - Method one: Rectangular integral approx. rule
% - Method two: DCT
% - Method three: Barycentric formula
% Algorithm two: evaluateOn()
% Numerics: Define Forward Euler
% Algorithm three: differentiation of a Cheb series
% - Method one: via DCT (todo...)
% - Method two: via recursion formula
% - Method three: via finite differences and repeated interpolantThrough()
% Final application: interpolantThrough(), u_1 = alpha * dt * diff(diff(u_0)), evaluateOn()
% Results

\begin{document}
  \pagestyle{plain}
  \begin{center}
    \vspace*{-2.5cm}
    \Large \topictitle \\
    \vspace{.3cm}

    \normalsize Special Topic on \textcolor{themecolor3}{\textsc{\course}}\\
    \normalsize Candidate Number: \textcolor{themecolor3}{\candidatenumber}
    \vspace{.3cm}
  \end{center}

  \begin{abstract}
    This work shall attempt to numerically solve the heat equation $u_t = \alpha u_{xx}$ with Dirichlet boundary conditions over the domain $[-1, 1] \times [0, T]$ by representing the spatial component as a \textit{Chebfun} (Chebyshev series) and moving on in time by the Forward Euler numerical scheme.
    \vspace*{0.2cm}

    \noindent
    \textbf{Our Goal:}
    Numerically obtain the solution $u(x, T)$ of
    \vspace*{-0.2cm}
    $$\begin{cases}
        \frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2} \quad & u: [-1, 1] \times [0, T] \mapsto \R,\, T \in \R^+,\; \alpha \in \R^+ \\
        u(x_j, 0) = u_0(x_j) \quad                                                     & \forall x_j \in X_N,\; N \in \N,\, N > 1, \; u_0: [-1, 1] \mapsto \R \\
        u(b, t) = u_0(b)                                                               & \forall b \in \{-1, 1\},\; \forall t \in (0, T] \,.
      \end{cases}$$
    \vspace*{0.05cm}

    The implementation, centered around what we will refer to as \textbf{\textcolor{themecolor3}{TschebFun}}, including three major algorithms \texttt{\textcolor{themecolor3}{TschebFun}::\textcolor{themecolor2}{interpolantThrough}()}, \texttt{\textcolor{themecolor3}{TschebFun}::\textcolor{themecolor2}{evaluateOn}()} and \texttt{\textcolor{themecolor3}{TschebFun}::\textcolor{themecolor2}{derivative}()}, is done manually in C++, extended to work as a Python module and for demonstration, even features a high-level graphical interface to play with.
    Finally, we will compare the numerical results with the output of \textit{Chebfun}'s high-level \texttt{pde15s()}.
  \end{abstract}

  \begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/screenshot.png}
    \caption{Screenshot of the graphical user interface. After entering an initial expression $u_0(x)$, depicted in grey, the simulation will run upon pressing 'Start'. The solution at time $t$, depicted in blue, is represented as a Chebyshev series of degree 29.}
  \end{figure}

  \pagebreak
  \pagestyle{normal}

  \tableofcontents
  \pagebreak

  \section{Motivation}
  Partial differential equations are notoriously hard to solve. One more possible approach to make way in this important class of problems is by the technique of spectral methods, incidentally closely related to finite element methods.
  The key idea is to perform the problem solution by representation of the occurring functions in a certain basis.
  For non-periodic problem settings, \textsc{Chebyshev} series are a fantastic choice.

  \subsection{The heat equation and its solution}
  Classical approaches to solving the heat equation are

  \begin{itemize}
    \item Using the separation Ansatz
          $$u(x, t) = \underline{X}(x) \underline{T}(t), \quad X: [-1, 1] \mapsto \R, \quad \underline{T}: [0, T] \mapsto \R$$

    \item By Fourier-analysis (similar to below, or maybe even simpler: differentiation simply multiplies the Fourier coefficients by $ik$).

    \item Numerically, a finite difference scheme such as
          $$\frac{U_{j}^{(n+1)} - U_{j}^{(n)}}{\Delta t} = \alpha \frac{U_{j+1}^{(n)} - 2 U_{j}^{(n)} + U_{j-1}^{(n)}}{(\Delta x)^2}$$
  \end{itemize}

  \todo{elaborate}

  \section{Chebyshev Interpolation}
  Let $\N$ denote the nonnegative integers, so $0 \in \N$.

  \begin{definition}{Chebyshev polynomial}{chebpoly}
    Chebyshev\footnote{named after Pafnuty Lvovich \textsc{Chebyshev}, alternatively transliterated as Tchebycheff, Tchebyshev (French) or \textsc{Tschebyschow} (German)} polynomials $T_k: \R \mapsto \R$ are functions satisfying
    \begin{align*}
      T_k(x) = T_k(\cos \theta) := \cos(k \theta) = \frac{1}{2} (z^k + z^{-k}) \\
      z := \e^{i \theta},\quad x := \Re(z) = \cos(\theta) = \frac{1}{2}(z + z^{-1})
    \end{align*}
    for degree $k \in \N$. Then, $T_0(x) = 1$, $T_1(x) = x$, $T_2(x) = 2x^2-1$, and so on.
  \end{definition}

  These relations between $x$, $z$ and $\theta$ reveal fundamental connections between three famous basis sets: \textsc{Chebyshev}, \textsc{Laurent} and \textsc{Fourier}.
  \todo{elaborate}

  \begin{theorem}{Chebyshev Recursion Formula}{chebrecursion}
    The Chebyshev polyomials satisfy the three-term recurrence relation $$T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x) \,.$$
  \end{theorem}
  \begin{proof}{\autoref{thm:chebrecursion}}
    For $k > 1$,
    \begin{align*}
      2x T_k(x) - T_{k-1}(x) & = 2x \frac{1}{2} (z^k + z^{-k}) - \frac{1}{2} (z^{k-1} + z^{-(k-1)})                       \\
                             & = 2 \frac{1}{2}(z + z^{-1}) \frac{1}{2}(z^k + z^{-k}) - \frac{1}{2} (z^{k-1} + z^{-k+1})   \\
                             & = \frac{1}{2} (z^{k+1} + z^{k-1} + z^{-k+1} + z^{-k-1}) - \frac{1}{2} (z^{k-1} + z^{-k+1}) \\
                             & = \frac{1}{2} (z^{k+1} + z^{-(k+1)}) = T_{k+1}(x)
    \end{align*}
  \end{proof}

  \subsection{An Orthogonal Basis}
  The Chebyshev polynomials also satisfy an \emph{orthogonality relation},
  $$\langle T_m, T_n \rangle := \int_{-1}^1 T_m(x) T_n(x) \frac{1}{\sqrt{1-x^2}} \ddx = \int_{\pi}^{0} \cos(m \theta) \cos(n \theta) \frac{-\sin(\theta)}{\sqrt{1-\cos^2(\theta)}} \dd\theta \,,$$
  which becomes, with the fitting substitution $x = \cos(\theta)$ and $\ddx = -\sin(\theta) \dd\theta$,
  \begin{align*}
    \langle T_m, T_n \rangle & = \int_0^\pi T_m(\cos \theta) T_n(\cos \theta) \frac{\sin \theta}{\sin \theta}\dd\theta = \int_0^\pi \cos(m \theta) \cos(n \theta) \dd\theta                            \\
                             & = \frac{1}{2} \int_0^\pi \big(\underbrace{\cos((m+n) \theta)}_{=\cos(2m\theta) \text{ for } m=n} + \underbrace{\cos((m-n) \theta)}_{=1 \text{ for } m=n}\big) \dd\theta
  \end{align*}
  along with the knowledge that $\int_0^\pi \cos(k \theta) \dd\theta = k^{-1} \left[\sin(k\theta)\right]_0^\pi = 0$ for $k \in \Z \backslash \{0\}$,
  $$\langle T_m, T_n \rangle = \int_0^\pi T_m(\cos \theta) T_n(\cos \theta) \dd\theta = \begin{cases}
      0     & \text{ for } m \neq n     \\
      \pi/2 & \text{ for } m = n \neq 0 \\
      \pi   & \text{ for } m = n = 0
    \end{cases}$$
  which can be effectively utilised to define a function space $(\mathcal{T}, +, \cdot)$ in the \emph{orthogonal} basis of Chebyshev polynomials $\mathcal{T} := \{T_k\}_{k \in \N}$.
  % TODO: find good notation for T, the set of T_k and the function space (set of functions) and function_space_N (in N coeffs)
  Note that the operation $\langle \cdot, \cdot \rangle$ satisfies all axioms of an authentic inner product (linearity, etc.) over a function space due to the linearity of the integral.

  In the following proceedings, we will restrict our view on functions over the interval $[-1, 1] \subset \R$.
  Any (real) Lipschitz-continuous function $f \in \mathcal{C}_L$, where $\cC_L := \{g: [-1, 1] \mapsto \R \;|\; \exists L \text{ s.t. } \forall x_1, x_2 \in \R, \; |g(x_1) - g(x_2)| \le L \cdot |x_1-x_2|\}$ can be represented in the Chebyshev basis $\cT$, as Lipschitz continuity is a sufficient condition for absolute and uniform convergence of the corresponding series representation
  $$f(x) = \sum_{k=0}^\infty a_k T_k(x), \quad a_k \in \R,\quad k \in \N \,.$$

  Utilising orthogonality, for any $f \in \cC_L$, we find coefficients $a_l \in \R$ by 'right-multiplying' the equation $f = \sum_{k=0}^\infty a_k T_k$ with any one of the Chebyshev polynomials $T_l$.
  \begin{align*}
    \langle f, T_l \rangle & = \langle \sum_{k=0}^\infty a_k T_k, T_l \rangle = \int_0^\pi a_k T_k(\cos \theta) T_l(\cos \theta) \dd\theta \\
                           & = \sum_{k=0}^\infty a_k \langle T_k, T_l \rangle \quad \text{ \textcolor{gray}{by linearity}}                 \\
                           & = \begin{cases}
                                 a_0 \pi   & \text{ for } l = 0    \\
                                 a_l \pi/2 & \text{ for } l \neq 0
                               \end{cases}
  \end{align*}
  which can easily be rearranged to give explicit relations for $a_0$ and $a_k$, summarised in the below theorem.
  \begin{theorem}{Chebyshev series coefficient formula}{cheb-coefficient-integrals}
    For any $f \in \cC_L$, one can obtain the Chebyshev series coefficients $a_k$, $k \in \N$ as
    \begin{align*}
      a_0 & = \frac{1}{\pi} \langle f, T_0 \rangle =  \frac{1}{\pi} \int_0^\pi f(\cos \theta) \dd\theta                                   \\
      a_k & = \frac{2}{\pi} \langle f, T_k \rangle = \frac{2}{\pi} \int_0^\pi f(\cos \theta) \cos(k \theta) \dd\theta, \quad k \neq 0 \,.
    \end{align*}
  \end{theorem}
  \begin{proof}
    As given in the discussion above.
    A different approach for the derivation of the explicit coefficient integrals can be found in \cite{atap} along with a complex analysis styled proof.
  \end{proof}

  Dealing with a numerical problem, we shall then approximate the above two integrals by the rectangular integral rule.

  \subsection{Well, and numerically?}
  As computers rarely allow us to store infinitely many coefficients $a_k$, we will work with the truncated Chebyshev series
  $$f_N(x) = \sum_{k=0}^{N-1} a_k T_k(x), \quad k \in \{0, ..., N\},\quad N \in \N, N > 1$$
  which approximates the function $f$ with a degree $N-1$ polynomial up to an error
  $$f(x) - f_N(x) = \sum_{k=0}^{\infty} a_k T_k(x) - \sum_{k=0}^{N-1} a_k T_k(x) = \sum_{k=N}^{\infty} a_k T_k(x) \,.$$

  \paragraph{Method One: Integral Approximation}
  Text

  \begin{theorem}{Rectangular integral rule}{integralapprox}
    $$\int_a^b f(x) \ddx = \lim_{N \rightarrow \infty} \frac{b-a}{N} \sum_{k=0}^{N-1} f(x_k), \quad x_k := a + \frac{b-a}{N} k$$
  \end{theorem}
  \cite[128]{bonthuis-cp}
  \todo{elaborate}

  Most importantly, this quadrature-style integral approximation is only one way of numerically determining the coefficients $a_k$.
  Another is to recognise the structure of the above integral for $k \neq 0$ as a cosine transform of the function $(f \circ \cos)$.

  \paragraph{Method Two: Relation to the DCT}
  Text

  \begin{definition}{Cosine Transform}{costrans}
    $$\hat{f}(\omega) := \int_{0}^{\pi} f(t) \cos(\omega t) \ddt$$
  \end{definition}

  \begin{definition}{DCT-II: Discrete Cosine Transform - type II}{dct}
    $$\hat{y}_k := \sum _{n=0}^{N-1}y_{n}\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(n+{\frac {1}{2}}\right)k\,\right]\qquad {\text{ for }}~k=0,\ \dots \ N-1~.$$
  \end{definition}

  Most significantly, this approach via the Discrete Cosine Transform can be sped up by means of the \emph{Fast Fourier Transform} \parencite{cooley-tukey-fft}.

  The above two methods demonstrate why it is sensible to choose to sample a function in \textit{chebpoints} instead of equispaced points, simply because the mathematics works out nicely in this basis.
  A much more fundamental numerical insight relating to the choice of points is the \emph{Runge phenomenon} \parencite{runge-phenomenon}.

  \paragraph{Method Three: Barycentric Interpolation Formula}
  Numerically speaking, a significant improvement to these two approaches can be made by using the \emph{Barycentric interpolation formula in Chebyshev points} \parencite{atap}.
  Given more time, one should implement this feature in TschebFun as well.

  \paragraph{Continuing with integral approximation ...}
  Text

  \begin{definition}{Chebyshev points}{chebpoints}
    From the equispaced points
    $$\Theta_N := \left\{\theta_j := \frac{j\pi}{N-1} \;\bigg|\; j = 0, ..., N-1\right\} \,,$$
    we can further define the Chebyshev points as the corresponding $\cos(\theta_j)$,
    $$X_N := \{x_j := \cos(\theta_j) \;|\; \theta_j \in \Theta_N\} \,.$$
  \end{definition}

  \begin{figure}[H]
    \centering
    \inputtikz{chebpoints}
    \caption{The Chebyshev points $\{x_j = \cos(\theta_j)\}$ are projections of the equispaced points $\{\theta_j\}$ on the unit circle onto the x-axis.}
  \end{figure}

  \subsection{A Numerical Issue}
  Wanting to interpolate through $N$ points, namely through $\{(x_j, f(x_j)) \;|\; x_j \in X_N\}$, the corresponding truncated Chebyshev series will have $N$ coefficients. To approximate the coefficient integral, we use \autoref{thm:integralapprox} without the limit.

  Even approximately speaking, the rectangular integral rule in application to \autoref{thm:cheb-coefficient-integrals} does, in some situations, not approach the correct coefficients.
  We now consider three different variations of the rectangular rule integral approximation, see why none of them are optimal in this situation and look at a possible resolution to this numerical issue, inspired by the DCT (\autoref{def:dct}).

  Intuitively, the problem is related to the endpoints of the interval $[0, \pi]$, the corresponding areas under the curve we aim to integrate and symmetry.
  In the following, consider the (near-) simplest case $N = 2$ and $f(x) = x$.
  The analytical solution is $a_0 = 0$ and $a_1 = 1$.

  \begin{itemize}
    \item With $\Theta_N$ as in \autoref{def:chebpoints}, consider the issue that
          $$a_1 = \frac{2}{\pi} \int_{0}^{\pi} \cos^2(\theta) \dd\theta \approx \frac{2}{N} \sum_{j=0}^{N-1} \cos^2\left(\frac{j \pi}{N-1}\right) = \frac{2}{2} \left(\cos^2(0) + \cos^2(\pi)\right) = 2 \neq 1 \,.$$
    \item Instead sampling at $\{\cos\left(\frac{j\pi}{N}\right) \;\big|\; j = 0, ..., N-1\}$,
          $$a_0 = \frac{1}{\pi} \int_0^\pi \cos(\theta) \dd\theta \approx \frac{1}{N} \sum_{j=0}^{N-1} \cos(\frac{j\pi}{N}) = \frac{1}{2} \left(\cos(0) + \cos(\pi/2)\right) = \frac{1}{2} \neq 0 \,.$$
    \item Even for a creative $\{\cos\left(\frac{j\pi}{N+1}\right) \;\big|\; j = 1, ..., N\}$,
          $$a_1 \approx \frac{2}{N} \sum_{j=1}^{N} \cos^2\left(\frac{j \pi}{N+1}\right) = \frac{2}{2} \left(\cos^2(\pi/3) + \cos^2(2\pi/3)\right) = \frac{1}{2} \neq 1 \,.$$
  \end{itemize}

  So we cannot use normal chebpoints in this interpolation method.

  \todo{elaborate}
  \begin{definition}{Modified Chebyshev points}{mod-chebpoints}
    $$\Theta_N := \left\{\theta_j := \frac{(j + \frac{1}{2})\pi}{N-1} \;\bigg|\; j = 0, ..., N-1\right\} \,,$$
    $$X_N := \{x_j := \cos(\theta_j) \;|\; \theta_j \in \Theta_N\} \,.$$
  \end{definition}
  \cite{CombTrig}.

  \subsection{The Algorithm}
  Pseudo-Vandermonde bla
  \begin{minted}{cpp}
    TschebFun TschebFun::interpolantThrough(Vector y) {
      int order = y.size(), degree = order - 1;
      Vector j = (xt::linspace((double)degree, 0.0, order) + 0.5) * (pi / order);
      Vector coeffs = xt::zeros_like(y); // as many coefficients as data points
      coeffs[0] = xt::sum(y)() / order;
      for (size_t k = 1; k < order; k++)
        coeffs[k] = (2.0 / order) * xt::sum(y * xt::cos(j * k))();
      return TschebFun(coeffs);
    }
  \end{minted}

  % TODO: maybe a small plot of a function next to its interpolant?

  \section{The Spectral Method}
  \subsection{Forward Euler}
  $$\frac{\partial u}{\partial t} \approx \frac{U_{n+1} - U_n}{\Delta t}$$
  $$\U_{n+1} \approx U_n + \Delta t \frac{\partial u}{\partial t} = U_n + \alpha \Delta t \frac{\partial^2 u}{\partial x^2}$$

  \begin{align*}
    \vec{a}^{(t+\Delta t)} = \vec{a}^{(t)} - \alpha \Delta t \cdot D_N^2 \vec{a}^{(t)}
  \end{align*}
  \todo{elaborate}

  \subsection{We need Differentiation}
  \begin{minted}{cpp}
    TschebFun TschebFun::derivative() {
      int n = coefficients.size();
      n = n - 1; // differentiation reduces the degree (order) by 1
      Vector coeffs = coefficients; // make a copy
      Vector derivative = xt::zeros<double>({n});
      for (size_t j = n; j > 2; j--) {
        derivative[j - 1] = (2 * j) * coeffs[j];
        coeffs[j - 2] += (j * coeffs[j]) / (j - 2);
      }
      if (n > 1)
        derivative[1] = 4 * coeffs[2];
      derivative[0] = coeffs[1];
      return TschebFun(derivative);
    }
  \end{minted}

  Differentiation matrix $D_N$ according to \cite{spectralmethods}.
  \todo{elaborate}

  \subsection{Enforcing boundary conditions}
  One way of forcing the boundary conditions, at least the first that came to my mind when thinking of this issue, is to pin down the two highest-order coefficients in the series representation after the iteration.

  Let $l := u_0(-1)$, $r := u_0(1)$.
  Recognise that
  \begin{align*}
    T_k(-1) & = T_k(\cos \pi) = \cos(k \pi) = (-1)^k \\
    T_k(1)  & = T_k(\cos 0) = \cos(k 0) = 1
  \end{align*}
  which leads to
  \begin{align*}
    u(-1, t) & = \sum_{k=0}^{N-1} a_k^{(t)} T_k(-1) & = & \overbrace{\sum_{k=0}^{N-3} a_k^{(t)} (-1)^k}^{:= \Sigma_1} & + & (-1)^{N-2} a_{N-2} & + & (-1)^{N-1} a_{N-1} & = l \\
    u(1, t)  & = \sum_{k=0}^{N-1} a_k^{(t)} T_k(1)  & = & \underbrace{\sum_{k=0}^{N-3} a_k^{(t)}}_{:= \Sigma_2}       & + & a_{N-2}            & + & a_{N-1}            & = r
  \end{align*}
  By adding up the above two equations, one obtains
  \begin{equation}
    \Sigma_1 + \Sigma_2 + \underbrace{\left((-1)^{N-2} + 1\right)}_{\in \{0, 2\}} a_{N-2} + \underbrace{\left((-1)^{N-1} + 1\right)}_{\in \{0, 2\}} a_{N-1} = l + r \label{eq:boundary-equation}
  \end{equation}

  For $N$ even: \autoref{eq:boundary-equation} has one unkown $a_{N-2} = \frac{l+r-\Sigma_1-\Sigma_2}{2},\; a_{N-1} = r - a_{N-2} - \Sigma_2$.

  For $N$ odd: \autoref{eq:boundary-equation} has one unkown $a_{N-1} = \frac{l+r-\Sigma_1-\Sigma_2}{2},\; a_{N-2} = r - a_{N-1} - \Sigma_2$.

  \paragraph{Adaptive time-steps}

  \subsection{The Destination}
  \begin{algorithm}[language=pseudo,caption={Heat Equation Forward-Euler}]
    currentU = currentU - $\alpha \Delta t$
  \end{algorithm}

  \section{Evaluation, Analysis, Comparison and Results}
  \subsection{Evaluation: The Clenshaw Algorithm}
  \begin{theorem}{Clenshaw recurrence relation}{clenshaw-recurrence}
  \end{theorem}
  \parencite[172-178]{art-of-sci-comp}.

  \begin{minted}{cpp}
    Vector TschebFun::evaluateOn(Vector x) {
      Vector U_kp2;
      Vector U_kp1 = xt::zeros_like(x);
      Vector U_k = xt::ones_like(x) * coefficients[coefficients.size() - 1];
      for (int k = coefficients.size() - 2; k >= 0; k--) {
        U_kp2 = U_kp1;
        U_kp1 = U_k;
        U_k = 2.0 * x * U_kp1 - U_kp2 + coefficients[k];
      }
      return (U_k - U_kp2 + coefficients[0]) / 2.0;
    }
  \end{minted}

  \subsection{Analysis: Interface to Python}
  Extension to a Python module, using \texttt{pybind11}.

  \begin{minted}{python}
    import heatfun, numpy as np
    u0 = lambda x: np.exp(-12 * x**2)
    x_of_interest = np.linspace(-1.0, 1.0, 500)
    cheb_x = heatfun.modifiedChebpoints(30)
    solution = heatfun.solve(u0(cheb_x), 0.01, x_of_interest)
  \end{minted}

  \subsection{Comparison: ChebFun}
  \inputminted{matlab}{../analysis/heatfun.m}

  % TODO: runtime benchmarks? Maybe only interpolation and evaluation

  \subsection{Results: On Target?}
  % gaussian squared error: 8.622487716018498e-08
  % sines squared error: 1.0126407911934125e-05
  % radiation squared error: 0.00023109224612169596
  % tanh-kernel squared error: 1.0602396930413146e-07
  % double-tanh squared error: 0.00019006286193809

  \begin{figure}[H]
    \centering
    \inputtikz{comparison-gaussian}
    \caption{Comparison of heatfun and chebfun}
  \end{figure}

  \begin{figure}[H]
    \centering
    \inputtikz{comparison-sines}
    \caption{Comparison of heatfun and chebfun}
  \end{figure}

  \begin{figure}[H]
    \centering
    \inputtikz{comparison-tanh-kernel}
    \caption{Comparison of heatfun and chebfun}
  \end{figure}

  \section{Outlook and Discussion}
  Given more time, one should.

  \printbibliography

  \appendix
  \section{Title of Appendix}
  Appendices are definitely not necessary and assessors are not obliged to read them so only use them for non-vital text, figures or calculations.

  \begin{figure}[H]
    \centering
    \inputtikz{comparison-radiation}
    \caption{Comparison of heatfun and chebfun}
  \end{figure}

  \begin{figure}[H]
    \centering
    \inputtikz{comparison-double-tanh}
    \caption{Comparison of heatfun and chebfun}
  \end{figure}

  \inputminted{cpp}{../solver/TschebFun.h}
\end{document}
